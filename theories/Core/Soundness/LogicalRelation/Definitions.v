From Coq Require Import Relation_Definitions RelationClasses.
From Equations Require Import Equations.

From Mcltt Require Import Base LibTactics.
From Mcltt.Core Require Import System.Definitions.
From Mcltt.Core Require Export Domain PER.Definitions Soundness.Weakening.Definition.

Import Domain_Notations.
Global Open Scope predicate_scope.

Generalizable All Variables.

Notation "'glu_typ_pred_args'" := (Tcons ctx (Tcons typ Tnil)).
Notation "'glu_typ_pred'" := (predicate glu_typ_pred_args).
Notation "'glu_typ_pred_equivalence'" := (@predicate_equivalence glu_typ_pred_args) (only parsing).
(* This type annotation is to distinguish this notation from others *)
Notation "Œì ‚ä¢ A ¬Æ R" := ((R Œì A : Prop) : (Prop : (Type : Type))) (in custom judg at level 80, Œì custom exp, A custom exp, R constr).

Notation "'glu_exp_pred_args'" := (Tcons ctx (Tcons exp (Tcons typ (Tcons domain Tnil)))).
Notation "'glu_exp_pred'" := (predicate glu_exp_pred_args).
Notation "'glu_exp_pred_equivalence'" := (@predicate_equivalence glu_exp_pred_args) (only parsing).
Notation "Œì ‚ä¢ M : A ¬Æ m ‚àà R" := (R Œì M A m : (Prop : (Type : Type))) (in custom judg at level 80, Œì custom exp, M custom exp, A custom exp, m custom domain, R constr).

Notation "'glu_sub_pred_args'" := (Tcons ctx (Tcons sub (Tcons env Tnil))).
Notation "'glu_sub_pred'" := (predicate glu_sub_pred_args).
Notation "'glu_sub_pred_equivalence'" := (@predicate_equivalence glu_sub_pred_args) (only parsing).
Notation "Œì ‚ä¢s œÉ ¬Æ œÅ ‚àà R" := (R Œì œÉ œÅ : (Prop : (Type : Type))) (in custom judg at level 80, Œì custom exp, œÉ custom exp, œÅ custom domain, R constr).

Notation "'DG' a ‚àà R ‚Üò P ‚Üò El" := (R P El a : (Prop : (Type : Type))) (in custom judg at level 90, a custom domain, R constr, P constr, El constr).
Notation "'EG' A ‚àà R ‚Üò Sb " := (R Sb A : (Prop : (Type : Type))) (in custom judg at level 90, A custom exp, R constr, Sb constr).

Inductive glu_nat : ctx -> exp -> domain -> Prop :=
| glu_nat_zero :
  `{ {{ Œì ‚ä¢ m ‚âà zero : ‚Ñï }} ->
     glu_nat Œì m d{{{ zero }}} }
| glu_nat_succ :
  `{ {{ Œì ‚ä¢ m ‚âà succ m' : ‚Ñï }} ->
     glu_nat Œì m' a ->
     glu_nat Œì m d{{{ succ a }}} }
| glu_nat_neut :
  `{ per_bot c c ->
     (forall {Œî œÉ v}, {{ Œî ‚ä¢w œÉ : Œì }} -> {{ Rne c in length Œî ‚Üò v }} -> {{ Œî ‚ä¢ m[œÉ] ‚âà v : ‚Ñï }}) ->
     glu_nat Œì m d{{{ ‚áë ‚Ñï c }}} }.

#[export]
Hint Constructors glu_nat : mcltt.

Definition nat_glu_typ_pred i : glu_typ_pred := fun Œì M => {{ Œì ‚ä¢ M ‚âà ‚Ñï : Type@i }}.
Arguments nat_glu_typ_pred i Œì M/.

Definition nat_glu_exp_pred i : glu_exp_pred := fun Œì m M a => {{ Œì ‚ä¢ M ¬Æ nat_glu_typ_pred i }} /\ glu_nat Œì m a.
Arguments nat_glu_exp_pred i Œì m M a/.

Definition neut_glu_typ_pred i C : glu_typ_pred :=
  fun Œì M => {{ Œì ‚ä¢ M : Type@i }} /\
            (forall Œî œÉ V, {{ Œî ‚ä¢w œÉ : Œì }} -> {{ Rne C in length Œî ‚Üò V }} -> {{ Œî ‚ä¢ M[œÉ] ‚âà V : Type@i }}).
Arguments neut_glu_typ_pred i C Œì M/.

Inductive neut_glu_exp_pred i C : glu_exp_pred :=
| mk_neut_glu_exp_pred :
    `{ {{ Œì ‚ä¢ M ¬Æ neut_glu_typ_pred i C }} ->
       {{ Dom c ‚âà c ‚àà per_bot }} ->
       (forall Œî œÉ V v, {{ Œî ‚ä¢w œÉ : Œì }} ->
                      {{ Rne C in length Œî ‚Üò V }} ->
                      {{ Rne c in length Œî ‚Üò v }} ->
                      {{ Œî ‚ä¢ m[œÉ] ‚âà v : M[œÉ] }}) ->
       {{ Œì ‚ä¢ m : M ¬Æ ‚áë A c ‚àà neut_glu_exp_pred i C }} }.

Inductive pi_glu_typ_pred i
  (IR : relation domain)
  (IP : glu_typ_pred)
  (IEl : glu_exp_pred)
  (OP : forall c (equiv_c : {{ Dom c ‚âà c ‚àà IR }}), glu_typ_pred) : glu_typ_pred :=
| mk_pi_glu_typ_pred :
    `{ {{ Œì ‚ä¢ M ‚âà Œ† IT OT : Type@i }} ->
       {{ Œì , IT ‚ä¢ OT : Type@i }} ->
       (forall Œî œÉ, {{ Œî ‚ä¢w œÉ : Œì }} -> {{ Œî ‚ä¢ IT[œÉ] ¬Æ IP }}) ->
       (forall Œî œÉ m a,
           {{ Œî ‚ä¢w œÉ : Œì }} ->
           {{ Œî ‚ä¢ m : IT[œÉ] ¬Æ a ‚àà IEl }} ->
           forall (equiv_a : {{ Dom a ‚âà a ‚àà IR }}),
             {{ Œî ‚ä¢ OT[œÉ,,m] ¬Æ OP _ equiv_a }}) ->
       {{ Œì ‚ä¢ M ¬Æ pi_glu_typ_pred i IR IP IEl OP }} }.

Inductive pi_glu_exp_pred i
  (IR : relation domain)
  (IP : glu_typ_pred)
  (IEl : glu_exp_pred)
  (elem_rel : relation domain)
  (OEl : forall c (equiv_c : {{ Dom c ‚âà c ‚àà IR }}), glu_exp_pred): glu_exp_pred :=
| mk_pi_glu_exp_pred :
  `{ {{ Œì ‚ä¢ m : M }} ->
     {{ Dom a ‚âà a ‚àà elem_rel }} ->
     {{ Œì ‚ä¢ M ‚âà Œ† IT OT : Type@i }} ->
     {{ Œì , IT ‚ä¢ OT : Type@i }} ->
     (forall Œî œÉ, {{ Œî ‚ä¢w œÉ : Œì }} -> {{ Œî ‚ä¢ IT[œÉ] ¬Æ IP }}) ->
     (forall Œî œÉ m' b,
         {{ Œî ‚ä¢w œÉ : Œì }} ->
         {{ Œî ‚ä¢ m' : IT[ œÉ ] ¬Æ b ‚àà IEl }} ->
         forall (equiv_b : {{ Dom b ‚âà b ‚àà IR }}),
         exists ab, {{ $| a & b |‚Üò ab }} /\ {{ Œî ‚ä¢ m[œÉ] m' : OT[œÉ,,m'] ¬Æ ab ‚àà OEl _ equiv_b }}) ->
     {{ Œì ‚ä¢ m : M ¬Æ a ‚àà pi_glu_exp_pred i IR IP IEl elem_rel OEl }} }.

#[export]
Hint Constructors neut_glu_exp_pred pi_glu_typ_pred pi_glu_exp_pred : mcltt.

Definition univ_glu_typ_pred j i : glu_typ_pred := fun Œì T => {{ Œì ‚ä¢ T ‚âà Type@j :  Type@i }}.
Arguments univ_glu_typ_pred j i Œì T/.

Section Gluing.
  Variable
    (i : nat)
      (glu_univ_typ_rec : forall {j}, j < i -> domain -> glu_typ_pred).

  Definition univ_glu_exp_pred' {j} (lt_j_i : j < i) : glu_exp_pred :=
    fun Œì m M A =>
      {{ Œì ‚ä¢ m : M }} /\
        {{ Œì ‚ä¢ M ‚âà Type@j : Type@i }} /\
        {{ Œì ‚ä¢ m ¬Æ glu_univ_typ_rec lt_j_i A }}.

  #[global]
  Arguments univ_glu_exp_pred' {j} lt_j_i Œì m M A/.

  Inductive glu_univ_elem_core : glu_typ_pred -> glu_exp_pred -> domain -> Prop :=
  | glu_univ_elem_core_univ :
    `{ forall typ_rel
         el_rel
         (lt_j_i : j < i),
          typ_rel <‚àô> univ_glu_typ_pred j i ->
          el_rel <‚àô> univ_glu_exp_pred' lt_j_i ->
          {{ DG ùïå@j ‚àà glu_univ_elem_core ‚Üò typ_rel ‚Üò el_rel }} }

  | glu_univ_elem_core_nat :
    `{ forall typ_rel el_rel,
          typ_rel <‚àô> nat_glu_typ_pred i ->
          el_rel <‚àô> nat_glu_exp_pred i ->
          {{ DG ‚Ñï ‚àà glu_univ_elem_core ‚Üò typ_rel ‚Üò el_rel }} }

  | glu_univ_elem_core_pi :
    `{ forall (in_rel : relation domain)
         IP IEl
         (OP : forall c (equiv_c_c : {{ Dom c ‚âà c ‚àà in_rel }}), glu_typ_pred)
         (OEl : forall c (equiv_c_c : {{ Dom c ‚âà c ‚àà in_rel }}), glu_exp_pred)
         typ_rel el_rel
         (elem_rel : relation domain),
          {{ DG a ‚àà glu_univ_elem_core ‚Üò IP ‚Üò IEl }} ->
          {{ DF a ‚âà a ‚àà per_univ_elem i ‚Üò in_rel }} ->
          (forall {c} (equiv_c : {{ Dom c ‚âà c ‚àà in_rel }}) b,
              {{ ‚ü¶ B ‚üß p ‚Ü¶ c ‚Üò b }} ->
              {{ DG b ‚àà glu_univ_elem_core ‚Üò OP _ equiv_c ‚Üò OEl _ equiv_c }}) ->
          {{ DF Œ† a p B ‚âà Œ† a p B ‚àà per_univ_elem i ‚Üò elem_rel }} ->
          typ_rel <‚àô> pi_glu_typ_pred i in_rel IP IEl OP ->
          el_rel <‚àô> pi_glu_exp_pred i in_rel IP IEl elem_rel OEl ->
          {{ DG Œ† a p B ‚àà glu_univ_elem_core ‚Üò typ_rel ‚Üò el_rel }} }

  | glu_univ_elem_core_neut :
    `{ forall typ_rel el_rel,
          {{ Dom b ‚âà b ‚àà per_bot }} ->
          typ_rel <‚àô> neut_glu_typ_pred i b ->
          el_rel <‚àô> neut_glu_exp_pred i b ->
          {{ DG ‚áë a b ‚àà glu_univ_elem_core ‚Üò typ_rel ‚Üò el_rel }} }.
End Gluing.

#[export]
Hint Constructors glu_univ_elem_core : mcltt.

Equations glu_univ_elem (i : nat) : glu_typ_pred -> glu_exp_pred -> domain -> Prop by wf i :=
| i => glu_univ_elem_core i (fun j lt_j_i A Œì M => exists P El, {{ DG A ‚àà glu_univ_elem j ‚Üò P ‚Üò El }} /\ {{ Œì ‚ä¢ M ¬Æ P }}).

Definition glu_univ_typ (i : nat) (A : domain) : glu_typ_pred :=
  fun Œì M => exists P El, {{ DG A ‚àà glu_univ_elem i ‚Üò P ‚Üò El }} /\ {{ Œì ‚ä¢ M ¬Æ P }}.
Arguments glu_univ_typ i A Œì M/.

Definition univ_glu_exp_pred j i : glu_exp_pred :=
    fun Œì m M A =>
      {{ Œì ‚ä¢ m : M }} /\ {{ Œì ‚ä¢ M ‚âà Type@j : Type@i }} /\
        {{ Œì ‚ä¢ m ¬Æ glu_univ_typ j A }}.
Arguments univ_glu_exp_pred j i Œì t T a/.

Section GluingInduction.
  Hypothesis
    (motive : nat -> glu_typ_pred -> glu_exp_pred -> domain -> Prop)

      (case_univ :
        forall i (j : nat)
          (typ_rel : glu_typ_pred) (el_rel : glu_exp_pred) (lt_j_i : j < i),
          (forall P El A, {{ DG A ‚àà glu_univ_elem j ‚Üò P ‚Üò El }} -> motive j P El A) ->
          typ_rel <‚àô> univ_glu_typ_pred j i ->
          el_rel <‚àô> univ_glu_exp_pred j i ->
          motive i typ_rel el_rel d{{{ ùïå @ j }}})

      (case_nat :
        forall i (typ_rel : glu_typ_pred) (el_rel : glu_exp_pred),
          typ_rel <‚àô> nat_glu_typ_pred i ->
          el_rel <‚àô> nat_glu_exp_pred i ->
          motive i typ_rel el_rel d{{{ ‚Ñï }}})

      (case_pi :
        forall i (a : domain) (B : typ) (p : env) (in_rel : relation domain) (IP : glu_typ_pred)
          (IEl : glu_exp_pred) (OP : forall c : domain, {{ Dom c ‚âà c ‚àà in_rel }} -> glu_typ_pred)
          (OEl : forall c : domain, {{ Dom c ‚âà c ‚àà in_rel }} -> glu_exp_pred) (typ_rel : glu_typ_pred) (el_rel : glu_exp_pred)
          (elem_rel : relation domain),
          {{ DG a ‚àà glu_univ_elem i ‚Üò IP ‚Üò IEl }} ->
          motive i IP IEl a ->
          {{ DF a ‚âà a ‚àà per_univ_elem i ‚Üò in_rel }} ->
          (forall (c : domain) (equiv_c : {{ Dom c ‚âà c ‚àà in_rel }}) (b : domain),
              {{ ‚ü¶ B ‚üß p ‚Ü¶ c ‚Üò b }} ->
              {{ DG b ‚àà glu_univ_elem i ‚Üò OP c equiv_c ‚Üò OEl c equiv_c }}) ->
          (forall (c : domain) (equiv_c : {{ Dom c ‚âà c ‚àà in_rel }}) (b : domain),
              {{ ‚ü¶ B ‚üß p ‚Ü¶ c ‚Üò b }} ->
              motive i (OP c equiv_c) (OEl c equiv_c) b) ->
          {{ DF Œ† a p B ‚âà Œ† a p B ‚àà per_univ_elem i ‚Üò elem_rel }} ->
          typ_rel <‚àô> pi_glu_typ_pred i in_rel IP IEl OP ->
          el_rel <‚àô> pi_glu_exp_pred i in_rel IP IEl elem_rel OEl ->
          motive i typ_rel el_rel d{{{ Œ† a p B }}})

      (case_neut :
        forall i (b : domain_ne) (a : domain)
          (typ_rel : glu_typ_pred)
          (el_rel : glu_exp_pred),
          {{ Dom b ‚âà b ‚àà per_bot }} ->
          typ_rel <‚àô> neut_glu_typ_pred i b ->
          el_rel <‚àô> neut_glu_exp_pred i b ->
          motive i typ_rel el_rel d{{{ ‚áë a b }}})
  .

  #[local]
  Ltac def_simp := simp glu_univ_elem in *.

  #[derive(equations=no, eliminator=no), tactic="def_simp"]
  Equations glu_univ_elem_ind i P El a
    (H : glu_univ_elem i P El a) : motive i P El a by wf i :=
  | i, P, El, a, H =>
      glu_univ_elem_core_ind
        i
        (fun j lt_j_i A Œì M => glu_univ_typ j A Œì M)
        (motive i)
        (fun j typ_rel el_rel lt_j_i Hty Hel =>
           case_univ i j typ_rel el_rel lt_j_i
             (fun P El A H => glu_univ_elem_ind j P El A H)
             Hty
             Hel)
        (case_nat i)
        _ (* (case_pi i) *)
        (case_neut i)
        P El a
        _.
  Next Obligation.
    eapply (case_pi i); def_simp; eauto.
  Qed.
End GluingInduction.

Inductive glu_neut i A Œì m M c : Prop :=
| mk_glu_neut :
    {{ Œì ‚ä¢ m : M }} ->
    {{ Œì ‚ä¢ M ¬Æ glu_univ_typ i A }} ->
    {{ Dom c ‚âà c ‚àà per_bot }} ->
    (forall Œî œÉ a, {{ Œî ‚ä¢w œÉ : Œì }} -> {{ Rne c in length Œî ‚Üò a }} -> {{ Œî ‚ä¢ m[œÉ] ‚âà a : M[œÉ] }}) ->
    {{ Œì ‚ä¢ m : M ¬Æ c ‚àà glu_neut i A }}.

Inductive glu_norm i A Œì m M a : Prop :=
| mk_glu_norm :
    {{ Œì ‚ä¢ m : M }} ->
    {{ Œì ‚ä¢ M ¬Æ glu_univ_typ i A }} ->
    {{ Dom ‚áì A a ‚âà ‚áì A a ‚àà per_top }} ->
    (forall Œî œÉ b, {{ Œî ‚ä¢w œÉ : Œì }} -> {{ Rnf ‚áì A a in length Œî ‚Üò b }} -> {{ Œî ‚ä¢ m [ œÉ ] ‚âà  b : M [ œÉ ] }}) ->
    {{ Œì ‚ä¢ m : M ¬Æ a ‚àà glu_norm i A }}.

Inductive glu_typ i A Œì M : Prop :=
| mk_glu_typ : forall P El,
    {{ Œì ‚ä¢ M : Type@i }} ->
    {{ DG A ‚àà glu_univ_elem i ‚Üò P ‚Üò El }} ->
    (forall Œî œÉ a, {{ Œî ‚ä¢w œÉ : Œì }} -> {{ Rtyp A in length Œî ‚Üò a }} -> {{ Œî ‚ä¢ M[œÉ] ‚âà a : Type@i }}) ->
    {{ Œì ‚ä¢ M ¬Æ glu_typ i A }}.

Ltac invert_glu_rel1 :=
  match goal with
  | H : pi_glu_typ_pred _ _ _ _ _ _ _ |- _ =>
      progressive_invert H
  | H : pi_glu_exp_pred _ _ _ _ _ _ _ _ _ _ |- _ =>
      progressive_invert H
  | H : neut_glu_typ_pred _ _ _ _ |- _ =>
      progressive_invert H
  | H : neut_glu_exp_pred _ _ _ _ _ _ |- _ =>
      progressive_invert H
  end.

Variant glu_rel_typ_sub i Œî A œÉ œÅ : Prop :=
| mk_glu_typ_sub :
  `{ forall P El,
        {{ ‚ü¶ A ‚üß œÅ ‚Üò a }} ->
        {{ DG a ‚àà glu_univ_elem i ‚Üò P ‚Üò El }} ->
        {{ Œî ‚ä¢ A[œÉ] ¬Æ P }} ->
        glu_rel_typ_sub i Œî A œÉ œÅ }.

Definition nil_glu_sub_pred : glu_sub_pred :=
  fun Œî œÉ œÅ => {{ Œî ‚ä¢s œÉ : ‚ãÖ }}.
Arguments nil_glu_sub_pred Œî œÉ œÅ/.

(* The parameters are ordered differently from the Agda version
   so that we can return "glu_sub_pred". *)
Variant cons_glu_sub_pred i Œì A (TSb : glu_sub_pred) : glu_sub_pred :=
| mk_cons_glu_sub_pred :
  `{ forall P El,
        {{ Œî ‚ä¢s œÉ : Œì, A }} ->
        (* Do we need the following argument?
           In other words, is it possible to prove that "TSb" respects
           wf_sub_eq without the following condition? *)
        {{ Œî ‚ä¢s Wk ‚àò œÉ ‚âà Wk‚àòœÉ : Œì }} ->
        {{ ‚ü¶ A ‚üß œÅ ‚ÜØ ‚Üò a }} ->
        {{ DG a ‚àà glu_univ_elem i ‚Üò P ‚Üò El }} ->
        {{ Œî ‚ä¢ #0[œÉ] : A[Wk‚àòœÉ] ¬Æ ~(œÅ 0) ‚àà El }} ->
        {{ Œî ‚ä¢s œÉ ¬Æ œÅ ‚àà cons_glu_sub_pred i Œì A TSb }} }.

Inductive glu_ctx_env : glu_sub_pred -> ctx -> Prop :=
| glu_ctx_env_nil :
  `{ forall Sb,
        Sb <‚àô> nil_glu_sub_pred ->
        {{ EG ‚ãÖ ‚àà glu_ctx_env ‚Üò Sb }} }
| glu_ctx_env_cons :
  `{ forall i TSb Sb,
        {{ EG Œì ‚àà glu_ctx_env ‚Üò TSb }} ->
        {{ Œì ‚ä¢ A : Type@i }} ->
        (forall Œî œÉ œÅ,
            {{ Œî ‚ä¢s œÉ ¬Æ œÅ ‚àà TSb }} ->
            glu_rel_typ_sub i Œî A œÉ œÅ) ->
        Sb <‚àô> cons_glu_sub_pred i Œì A TSb ->
        {{ EG Œì, A ‚àà glu_ctx_env ‚Üò Sb }} }.

Variant glu_rel_exp_sub i Œî M A œÉ œÅ : Prop :=
| mk_glu_exp_sub :
  `{ forall P El,
        {{ ‚ü¶ A ‚üß œÅ ‚Üò a }} ->
        {{ ‚ü¶ M ‚üß œÅ ‚Üò m }} ->
        {{ DG a ‚àà glu_univ_elem i ‚Üò P ‚Üò El }} ->
        {{ Œî ‚ä¢ M[œÉ] : A[œÉ] ¬Æ m ‚àà El }} ->
        glu_rel_exp_sub i Œî M A œÉ œÅ }.

Variant glu_rel_sub_sub Œî œÑ (Sb : glu_sub_pred) œÉ œÅ : Prop :=
| mk_glu_sub_sub :
  `{ {{ ‚ü¶ œÑ ‚üßs œÅ ‚Üò œÅ' }} ->
     {{ Œî ‚ä¢s œÑ ‚àò œÉ ¬Æ œÅ' ‚àà Sb }} ->
     glu_rel_sub_sub Œî œÑ Sb œÉ œÅ}.

Definition glu_rel_ctx Œì : Prop := exists Sb, {{ EG Œì ‚àà glu_ctx_env ‚Üò Sb }}.
Arguments glu_rel_ctx Œì/.

Definition glu_rel_exp Œì M A : Prop :=
  exists Sb,
    {{ EG Œì ‚àà glu_ctx_env ‚Üò Sb }} /\
      exists i,
      forall Œî œÉ œÅ,
        {{ Œî ‚ä¢s œÉ ¬Æ œÅ ‚àà Sb }} ->
        glu_rel_exp_sub i Œî M A œÉ œÅ.
Arguments glu_rel_exp Œì M A/.

Definition glu_rel_sub Œì œÑ Œì' : Prop :=
  exists Sb Sb',
    {{ EG Œì ‚àà glu_ctx_env ‚Üò Sb }} /\
    {{ EG Œì' ‚àà glu_ctx_env ‚Üò Sb' }} /\
      forall Œî œÉ œÅ,
        {{ Œî ‚ä¢s œÉ ¬Æ œÅ ‚àà Sb }} ->
        glu_rel_sub_sub Œî œÑ Sb' œÉ œÅ.
Arguments glu_rel_sub Œì œÑ Œì'/.

Notation "‚ä© Œì" := (glu_rel_ctx Œì) (in custom judg at level 80, Œì custom exp).
Notation "Œì ‚ä© M : A" := (glu_rel_exp Œì M A) (in custom judg at level 80, Œì custom exp, M custom exp, A custom exp).
Notation "Œì ‚ä©s œÑ : Œì'" := (glu_rel_sub Œì œÑ Œì') (in custom judg at level 80, Œì custom exp, œÑ custom exp, Œì' custom exp).
